---
import { parseMarkdownInline } from '../../utils/mdx'

interface Props {
  quote: string
  source?: string
}

const { quote, source } = Astro.props

const htmlSource = source ? parseMarkdownInline(source) : ''

// Strip any existing quotes and add curly quotes for consistent output
// Handles straight quotes ("), curly quotes (" " ' '), and single quotes (' ')
let trimmedQuote = quote.trim()

// Strip any leading quote (any type)
if (
  trimmedQuote.startsWith('"') ||
  trimmedQuote.startsWith('"') ||
  trimmedQuote.startsWith("'") ||
  trimmedQuote.startsWith("'")
) {
  trimmedQuote = trimmedQuote.slice(1)
}

// Strip any trailing quote (any type)
if (
  trimmedQuote.endsWith('"') ||
  trimmedQuote.endsWith('"') ||
  trimmedQuote.endsWith("'") ||
  trimmedQuote.endsWith("'")
) {
  trimmedQuote = trimmedQuote.slice(0, -1)
}

// Always use curly quotes for consistent styling
const formattedQuote = `“${trimmedQuote.trim()}”`
---

<div class="ps-space-s py-space-2xs border-l-4 border-primary mb-space-s">
  <blockquote class="text-step-1">
    <p>{formattedQuote}</p>
  </blockquote>
  {
    htmlSource && (
      <p>
        — <cite class="text-step-1" set:html={htmlSource} />
      </p>
    )
  }
</div>

<!--
  Styling rendered HTML from set:html

  Since set:html injects raw HTML that doesn't receive Astro's scoped data
  attributes, we use :global() to target injected child elements while keeping
  the parent selector scoped to this component.
-->
<style>
  /* Reset inherited prose styles for rendered HTML inside cite */
  cite {
    font-weight: 200;
    font-style: normal;
  }

  cite :global(strong) {
    color: inherit;
    font-weight: 400;
    font-style: italic;
  }

  cite :global(em) {
    font-style: italic;
  }
</style>
